---
layout: post
title: 그래프 [임시]
category: ds
---

그래프는 **정점**과 **간선**으로 이루어진 자료구조이다

차수(degree)는 각 정점에 대해서 간선으로 연결된 이웃한 정점의 개수가 바로 **차수**이다

그래프의 간선에는 **방향성**이 있을 수 있다

방향성이 없으면 **무방향 그래프**라고 하고 방향성이 있다면 **방향 그래프**라고 한다

방향 그래프에서는 자기에게서 나가는 간선의 개수는 **진출 차수**(outdegree)이고 들어오는 간선의 개수는 **진입 차수**(indegree)이다

**사이클**은 한 점에서 출발해서 자기 자신으로 돌아올 수 있는 경로를 말한다

**순환**(Cyclic graph) 그래프는 사이클이 하나라도 있어야 한다

사이클이 없으면 **비순환 그래프**(Acyclic graph)라고 한다

&nbsp;

모든 서로 다른 정점 쌍이 간선으로 연결된 그래프를 **완전 그래프**(Complete Graph)라고 한다

임의의 두 정점 사이 경로가 항상 존재하는 그래프는 **연결 그래프**(Connected Graph)라고 한다

**루프**는 한 정점에서 시작해서 같은 정점으로 들어오는 간선을 말한다

**단순 그래프**(Simple Graph)는 두 정점 사이 간선이 1개 이하이고 루프가 존재하지 않는 그래프이다

&nbsp;

#### 그래프의 표현법

첫 번째 방법으로는 **인접 행렬**을 이용한다

정점이 V개이고 간선이 E개일 때 어떤 두 점이 연결되어 있는지를 O(1)에 알 수 있다는 장점이 있다

가로와 세로가 각각 V인 2차원 배열이 필요하니 $$ O(V^2) $$ 의 공간이 필요하다

모든 정점의 목록을 알아내고 싶을 때 개수와 상관없이 시간복잡도가 O(V)이다


두 번째 방법으로는 **인접 리스트**를 이용한다

이 방법은 정점이 많고 간선은 상대적으로 작은 상황에서 공간을 절약할 수 있는 방식

경우에 따라 인접 행렬로는 절대 저장이 불가능해 인접 리스트를 써야만 하는 상황이 있다

V개의 리스트를 만들어 각 리스트에 자신과 연결된 정점을 넣으면 된다

인접 리스트는 O(V+E)의 공간이 필요하다 

&nbsp;

#### 인접 행렬과 인접 리스트의 시간 복잡도 비교

| 연산                             | 인접 행렬 (Adjacency Matrix) | 인접 리스트 (Adjacency List)      |
|----------------------------------|-------------------------------|------------------------------------|
| 간선 존재 여부 확인 (u → v)    | O(1)                          | O(degree(u))                       |
| 정점 u의 인접 노드 순회        | O(V)                          | O(degree(u))                       |
| 간선 추가 / 삭제             | O(1)                          | O(1)                               |
| 전체 간선 순회                 | O(V²)                         | O(V + E)                           |
| 메모리 사용량                | O(V²)                         | O(V + E)                           |

> - N: 정점(Node) 수  
> - E: 간선(Edge) 수  
> - degree(u): 정점 u에 연결된 간선 수