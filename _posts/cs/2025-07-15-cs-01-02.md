---
layout: post
title: 컴퓨터 구조 CS:APP 1장 - 2 -
category: cs
---

&nbsp;

# Index
  - [컴파일 시스템에 대한 이해가 필요한 이유](#컴파일-시스템에-대한-이해가-필요한-이유)
  - [버스(Buses)](#버스buses)
  - [입출력 장치](#입출력-장치)
  - [메인 메모리](#메인-메모리)
  - [프로세서](#프로세서)

#### 컴파일 시스템에 대한 이해가 필요한 이유

- 프로그램 성능 최적화하기 위하여 소스 코드들을   
    기계어 코드로 어떻게 번역하는지 알 필요가 있다  
    - 예를 들어 swtich 문 vs if-else 문 어떤게 효율적인가?  
    - 함수 호출 시 발생하는 오버헤드는 얼마나 되는가?  
    - while 루프는 for 루프보다 더 효율적일까?  
    - 포인터 참조가 배열 인덱스보다 더 효율적인가?  
    - 합계를 지역변수에 저장하면 참조 형태로 넘겨받은 인자들을  
      사용하는 것보다 왜 루프가 더 빨리 실행되는가?  
    - 수식 연산시 괄호를 단순히 재배치 하기만 해도 함수가 더 빨리 실행되는 이유는?  

    > 컴파일러가 코드를 어떻게 번역하는지 이해 -> 더 빠른 코드 작성 가능

&nbsp;

- 링크 에러 이해하기 위하여  
    - 링커가 참조를 풀어낼 수 없다고 할때 무엇을 의미하는가?
    - 정적변수와 전역변수의 차이는?
    - 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면?
    - 정적 라이브러리와 동적 라이브러리의 차이는?
    - 컴파일 명령을 쉘에서 입력할 때 명령어 라인의 라이브러리들의 순서는 무슨 의미가 있는가?
    - 왜 링커와 관련된 에러들은 실행하기전까지는 나타나지 않는걸까?
    
    > 여러 파일로 구성된 프로젝트에서 연결 오류를 해결하려면 링커의 동작 원리와 심볼 처리 방식에 대한 이해가 필요

&nbsp;

- 보안 약점(Security Hole)을 파악하기 위하여
    - **버퍼 오버플로우**의 취약성인 인터넷과 네트워크상의 보안 약점의 주요 원인인데
      이 **취약성**의 이유는 프로그래머가 신뢰할 수 없는 곳에서   
      획득한 데이터의 양과 형태를 주의 깊게 제한해야 할 필요를 거의 인식하지 못했기 때문  
      -> 프로그램 **스택에 데이터와 제어 정보**가 저장되는 방식을 이해가 필요

      > 메모리 구조(스택, 힙)와 함수 호출 구조 이해 -> 취약점 회피 가능

&nbsp;

#### 버스(Buses)

  ![시스템의 하드웨어 구성](/assets/images/cs/cs_app_01_02_1.png)

  시스템 내를 관통하는 전기적 배선군 = 버스(bus)  

  &nbsp;

  버스는 **컴포넌트**들 간에 바이트 정보를 전송하고  
  **워드**라고 하는 고정 크기의 바이트 단위로 데이터를 전송하도록 설계

  한 개의 워드를 구성하는 **바이트 수**는 시스템마다 보유하는 기본 시스템 변수이다

  워드의 크기 = 4바이트(32비트) or 8바이트(64바이트)

  &nbsp;

#### 입출력 장치

  그림의 시스템은 4개의 입출력 장치가 있다

  - 입력용 키보드와 마우스
  - 출력용 디스플레이
  - 데이터와 프로그램 장기저장을 위한 디스크 드라이브

  각 입출력 장치는 입출력 버스 or 컨트롤러 or 어댑터를 통해 연결된다

  컨트롤러 = 디바이스 자체가 칩셋 or 시스템의 머더보드에 장착된 구성요소

  어댑터 = 머더보드의 슬롯에 장착되는 카드

  컨트롤러와 어댑터 공통된 목적 = 입출력 버스와 장치들 간에 정보 교환을 중개

  &nbsp;

#### 메인 메모리

  > 메인 메모리는 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치

  물리적인 메인 메모리 = DRAM(Dynamic Random Access Memory)

  논리적인 메모리 = 연속적인 바이트들의 배열, 각각 0부터 시작해서 고유의 주소(배열의 인덱스)를 가지고 있다


&nbsp;

#### 프로세서

  > 주처리장치(CPU) 또는 프로세서는 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진

  &nbsp;

  프로세서 중심에는 워드 크기의 레지스터인 **프로그램 카운터(PC)**가 있다

  프로세서는 전원이 켜질때부터 꺼질때까지 프로그램 카운터가 가리키는 곳의 인스트럭션을

  반복적으로 실행하고 PC값이 다음 인스트럭션의 위치를 가르키도록 업데이트 한다

  PC가 가르키는 메모리로부터 인스트럭션을 읽어와서 비트들을 해석하여 동작을 실행하고

  PC를 다음 인스트럭션 위치로 업데이트 한다. 이 위치는 이전 위치와 연속적일 수도 있고 아닐 수도 있다

  이 인스트럭션 과정들은 메인 메모리, 레지스터 파일, 수식/논리 처리기(ALU) 주위를 순환한다
  
  레지스터 파일은 고유의 이름을 갖는 워드 크기의 레지스터 집합으로 구성되어 있다  

  &nbsp;

  적재(Load): 메인 메모리 -> 레지스터 | 한 바이트 또는 워드를 이전 값에 덮어쓰는 방식으로 복사  
  저장(Store): 레지스터 -> 메인 메모리 | 한 바이트 또는 워드를 이전 값을 덮어 쓰는 방식으로 복사  
  작업(Operate): 두 레지스터의 값을 ALU로 복사 | 두 개의 워드로 수식연산을 수행 후 결과를 덮어쓰기 방식 레지스터
  점프(Jump): 인스트럭션 자신 | 한 개의 워드를 추출하고 이것을 PC에 덮어쓰기 방식으로 복사

  &nbsp;

  ."\hello"를 입력했을때 내부 과정
  > Keyboard -> USB Controller -> I/O Bridge -> Bus Interface -> Register File -> System Bus -> Memory Bus -> Main Memory "hello"

  &nbsp;

  실행 파일 hello를 디스크에서 메인 메모리로 로딩 과정
  > Disk -> Disk Controller -> I/O Bridge -> Main Memory // hello code "hello, world\n"

  &nbsp;

  출력 스트링을 메모리에서 화면으로 기록하는 과정
  > Main Memory // hello code "hello, world\n" -> Memory Bus -> System Bus -> 
    Register File -> Bus Interface -> I/O Bridge -> I/O Bus -> Graphics Adapter -> Display // "hello, world\n"

  &nbsp;

<p style="display: flex; justify-content: space-between;">
  <a href="cs-01-01.html">이전</a>
  <a href="cs-01-03.html">다음</a>
</p>