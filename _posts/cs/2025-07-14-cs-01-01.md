---
layout: post 
title: 컴퓨터 구조 CS:APP 1장 - 1 -
category: cs
---

> 이 글은 Randal E. Bryant와 David R. O’Hallaron의 저서 《Computer Systems: A Programmer's Perspective》(CS:APP)를 참고하여 작성되었습니다.

아래의 순서는 ChatGPT의 도움을 받아 작성되었습니다.

<pre>
8086 (16비트)
  ↓
80286 (보호 모드 추가)
  ↓
80386 → IA-32 (32비트)
  ↓
80486, Pentium 계열
  ↓
x86-64 (AMD64 / Intel64) → 64비트 (현대 표준)
</pre>

1. 8086 마이크로프로세서 (1978)  
    - 16비트 아키텍처

    - 인텔의 x86 아키텍처의 출발점

    - 세그먼트 레지스터 사용

2. 80286 (286)
    - 여전히 16비트지만, 프로텍티드 모드 도입

3. 80386 (386)
    - IA-32 (x86 32비트) 등장

    - 32비트 워드 구조

    - 가상 메모리, 보호 모드, 링 구조 지원

4. IA-32 계열 발전
    - 80486 → Pentium → Pentium Pro → Core 시리즈

    - 여전히 32비트 기반

    - Core 2 Duo부터 64비트 지원

5. x86-64 (AMD64, Intel64)
    - 64비트 확장 아키텍처

    - AMD가 처음 설계, 이후 인텔이 채택

    - 레지스터 확장(RAX, RBX 등), 64비트 주소 공간

    - 현대 PC, 서버의 주류 아키텍처  


오늘날 대부분의 컴퓨터는 **x86-64 아키텍처**를 기반으로 동작

트랜지스터를 단일 칩에 더 많이 집적할 수 있게 되면서, 계산 능력과 메모리 주소 공간이 비약적으로 향상된 결과


---

컴퓨터에서의 산술 연산은 시스템의 정확성과 성능에 직접적인 영향을 미치기 때문에, 그 작동 원리를 올바르게 이해하는 것이 중요하다   

(x < y)를 (x - y < 0)으로 대체할 수 없는 이유 : 오버플로우의 가능성

(-y < -x)와 같은 수식으로도 대체하지 못함 :   
- 이는 2의 보수 표현 방식에서 음수와 양수의 범위가 비대칭적이기 때문이다. 예를 들어, 8비트 정수에서 -128은 표현 가능하지만 +128은 표현할 수 없다.

---

정보는 비트와 컨텍스트로 이루어진다

- 소스 프로그램은 0 또는 1로 표시되는 비트들의 연속

- 바이트라는 8비트 단위로 구성

- 대부분 시스템은 텍스트 문자 -> 아스키(ASCII) 표준을 사용

---

프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

- c를 시스템에서 실행 시키려면 저수준 기계어(인스트럭션)들로 번역되어야 한다

- 인스트럭션들은 어셈블리 단계에서 목적 파일로(.o)이라고 하는 형태로 합쳐져서 링커에 의해 결합되어 최종적으로 바이너리(exe) 디스크 파일로 저장된다

- 인스트럭션은 CPU가 이해하고 실행할 수 있는 기본 연산 명령어를 의미하며, 어셈블리는 이러한 인스트럭션을 사람이 읽고 쓰기 쉽게 기호화한 저수준 프로그래밍 언어  

---

리눅스에서 해당 명령어를 사용하면  

```linux
linux> gcc -o hello hello.c
```

hello.c -> hello.exe

<pre>
(.c -> .i)     전처리기  
      ↓  
(.i -> .s)     컴파일러  
      ↓  
(.s -> .o)     어셈블러  
      ↓  
(.o -> .exe)   링커  
</pre>  

→ 위 과정을 모두 합친 것이 '컴파일 시스템'이다


- 전처리 단계(cpp)  
    C 프로그램을 #문자로 시작하는 디렉티브에 따라 수정  
    시스템 헤더파일인 stdio.h를 프로그램 문장에 직접 삽입하라고 지시  
- 컴파일 단계(ccl)  
    .i를 .s로 번역하며 이 파일에는 어셈블리어 프로그램이 저장된다

```
    main:
        subq    $8, %rsp
        movl    $.LC0, %edi
        call    puts
        movl    $0, %eax
        addq    $8, %rsp
        ret
```

- 어셈블리 단계(as)  
    .s를 기계어 인스트럭션으로 번역하고, 이들을 재배치가능 목적프로그램의 형태로 묶어서 .o라는 목적파일에 그 결과를 저장

- 링크 단계(ld)    
    printf.o(표준 라이브러리)와 hello.o 파일과 결합 그 결과로 실행파일로 메모리에 적재된 이후 시스템에 의해 실행