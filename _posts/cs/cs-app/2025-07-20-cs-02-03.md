---
layout: post
title: 컴퓨터 구조 CS:APP 2장 - 3 -
category: cs
---

# Index
- [데이터의 크기](#데이터의-크기)
- [주소지정과 바이트 순서](#주소지정과-바이트-순서)

#### 데이터의 크기

  모든 컴퓨터는 **워드 크기**(word size)를 규격으로 갖는다

  이것은 **포인터**의 정규 크기를 표시함

  하나의 **가상주소** = 한 개의 **워드**로 인코딩되기 때문임

  시스템의 워드 크기는 가상 주소공간의 최대 크기를 결정함

  w 비트 워드 크기 -> 컴퓨터의 가상주소는 0 ~ $$ 2^w - 1 $$

  프로그램은 최대 $$ 2^w $$ 바이트에 접근 가능

  32비트의 워드 크기의 가상 주소공간의 크기를 **4기가** 바이트($$4 * 10^9$$)

  64비트 워드 크기로 확장되면서 **16엑사** 바이트 ($$1.84 * 10^{19}$$)의 가상 주소공간으로 확장됨

  &nbsp;

  대부분 64비트 컴퓨터들은 **역방향 호환성**을 가지고 있어서 32비트 머신들을 위해 컴파일된 프로그램도 실행 가능

  프로그램이 어떻게 컴파일되었는가에 따라 "32비트 프로그램" 또는 "64비트 프로그램"이라고 부름

  &nbsp;

  ![C 언어에서 숫자 데이터 타입들의 크기](/assets/images/cs/cs-app/cs-app-02-03-01.png)

  C언어의 데이터 타입들과 할당되는 바이트의 수를 그림과 같이 표현

  정수 데이터는 0과 음수, 양수를 표시하기 위해서 부호형(signed)와 비부호형(unsigned) 정수가 될 수 있다

  **long**은 32비트 프로그램에서는 대개 **4바이트**이고 64비트 프로그램에서는 **8바이트**

  예측하지 못한 문제들을 피하기 위해 **ISO C99**는 컴파일러와 컴퓨터 설정에 관계없이 데이터 크기가 고정된 자료형들을 제안

  **int32_t**와 **int64_t**는 각각 정확히 4바이트와 8바이트 크기를 갖는다

  프로그래머는 1바이트 부호형 값을 보장하기 위해서는 **signed char** 선언을 사용해야 함, char 자료형이 부호형인지 여부는 프로그램의 동작에 영향을 주지 않음

  > unsigned long = long unsigned

  &nbsp;

  대부분의 컴퓨터들은 두 개의 서로 다른 **부동소수점** 형식을 지원한다
  
  C에서는 float으로 선언하는 **단일정밀도**, double로 선언하는 **이중정밀도**, 각각 4바이트, 8바이트를 사용한다

  C언어 표준은 데이터 타입들이 표시할 수 있는 최저 한계값을 지정하고 있으나, 상위 한계값은 정의하지 않는다

  64비트 머신들로의 전환이 이루어짐에 따라 프로그램들을 옮기는 과정에서 워드 크기 의존성들이 버그로 발생되었다

#### 주소지정과 바이트 순서

  거의 모든 컴퓨터에서 멀티 바이트 객체는 **연속된** 바이트에 저장되며, 객체의 주소는 사용된 바이트의 **최소 주소**로 정함

  가장 **중요**한 비트 = Most Significant Bit

  어떤 컴퓨터들은 객체를 메모리에 가장 덜 중요한 바이트부터 저장하며, 어떤 컴퓨터들은 가장 중요한 바이트부터 저장

  가장 덜 중요한 바이트가 먼저 오는 것 - **리틀 엔디안** (대부분의 인텔 호환 머신)

  가장 중요한 바이트가 먼저 오는 것 - **빅 엔디안** (IBM, Oracle)

  리틀 엔디안이나 빅 엔디안이라는 용어는 **걸리버 여행기**에서 따온 것

  바이트 순서 관습을 다른 관습 대신에 선택해야 하는 **기술적 이유**는 없다

  - 문제가 되는 경우?

    1. **이진 데이터**가 네트워크를 통해 다른 컴퓨터로 전송될 때  

       이러한 문제들을 피하기 위해서 **송신** 측 컴퓨터가 내부 표시를 **네트워크 표준**으로 변경  

       **수신** 측 컴퓨터가 **네트워크 표준**을 자신의 내부 표시방식으로 변환하도록 하는 관습을 따라야 한다

    2. 정수 데이터를 나타내는 **바이트**들을 살펴볼 때
    
    3. 정상적인 타입 체계를 회피하도록 작성되었을 때 
        
        - 캐스트나 유니온을 사용해서 객체가 만들어졌을 때와는 다른 타입의 데이터로 참조될 수 있도록 할 수 있음  

포인터는 운영체제에 따라서 4바이트 주소와 8바이트 주소를 사용한다


<p style="display: flex; justify-content: space-between;">
  <a href="cs-02-02.html">이전</a>
  <a href="cs-02-04.html">다음</a>
</p>
