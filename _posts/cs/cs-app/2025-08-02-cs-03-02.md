---
layout: post
title: 컴퓨터 구조 CS:APP 3장 - 2 -
category: cs
---

![오퍼랜드의 형식](/assets/images/cs/cs-app/cs-app-03-02-01.png)

#### 오퍼랜드 식별자

대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다

**오퍼랜드**는 연산을 수행할 입력값과 그 결과를 저장할 목적지의 위치를 명시한다

오퍼랜드의 종류는 세 가지 타입으로 구분할 수 있다

1. immediate - 상수 값(하드코딩된 상수)
2. register - 레지스터의 저장된 데이터
3. memory reference - 연산에 사용되는 값이 메모리 어딘가에 저장된 값, 그 위치는 유효 주소(effective address) 계산을 통해 결정

주소 = base + (index × scale) + offset
s = 배율인자

s가 1, 2, 4, 8인 이유 = char, short, int, float, long, double 등 범위 내에서 결정되기 때문

#### 데이터 이동 인스트럭션

mov 계열 - 해당 계열은 데이터를 변형 없이 복사, 명령어 이름은 복사할 데이터의 크기에 따라 접미사가 붙음
- movb = 바이트 복사
- movw = 워드 복사
- movl = 더블 워드 복사
- movq = 쿼드 워드 복사

소스 오퍼랜드 - 상수, 레지스터 저장 값, 메모리 저장 값을 표시한다

목적 오퍼랜드 - 레지스터, 메모리 주소의 위치를 지정한다

x86-64 - 데이터 이동 인스트럭션에서 두 개의 오퍼랜드 모두가 메모리 위치에 올 수 없도록 제한

movl이 레지스터를 목적지로 쓰는 경우 - 레지스터의 상위 4바이트도 0으로 설정

movq - 32비트 2의 보수 숫자로 나타낼 수 있는 상수 소스 오퍼랜드들만을 갖는다

movabsq - 임의의 64비트 상수 값을 소스 오퍼랜드로 가질 수 있으며, 목적지로는 레지스터만을 가질 수 있다

movz - 목적지의 남은 바이트들을 모두 0으로 채운다

movs - 가장 중요한 비트를 반복해서 복사하는 부호 확장으로 채운다

&nbsp;

![c와 어셈블리 코드](/assets/images/cs/cs-app/cs-app-03-02-02.png)

exchange의 인스트럭션
- 두 개의 데이터 이동(movq)

- 함수가 호출된 위치로 리턴하는 인스트럭션(ret)

리턴 값을 레지스터 %rax에 저장해서 리턴하거나, 레지스터의 하위 부분 중의 하나로 리턴한다

이 코드의 두 가지 특징

1. C언어에서 포인터는 어셈블리어에서 단순히 주소라는 점

2. 포인터를 역참조하는 것은 포인터 값을 레지스터에 넣은 뒤, 이를 메모리 주소로 참조하는 방식이다

&nbsp;

#### 스택 데이터의 저장과 추출

![스택에 push 연산](/assets/images/cs/cs-app/cs-app-03-02-03.png)
- 스택에서 값을 꺼내 %rax에 저장  
스택 포인터를 8 증가 (pop 연산 효과)  

&nbsp;

![스택에 pop 연산](/assets/images/cs/cs-app/cs-app-03-02-04.png)
- 스택 포인터를 8 감소 (스택 공간 확보)  
현재 %rbp 값을 스택에 저장  

&nbsp;

스택에 데이터를 저장(push)하거나 스택에서 데이터를 추출(pop)하기 위해 사용한다

스택은 값들이 **후입선출** 형태로만 추가되거나 제거되는 자료구조이다

쿼드워드 값을 스택에 추가하려면, 스택 포인터를 8 감소시키고, 그 값을 스택 주소의 새로운 탑에 기록하는 것으로 구현된다



<p style="display: flex; justify-content: space-between;">
<a href="cs-03-01.html">이전</a>
<a href="cs-03-03.html">다음</a>
</p>