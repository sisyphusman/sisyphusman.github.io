---
layout: post
title: CS:APP malloc lab 프로젝트
category: cs
---

## 소개

이 과제에서는 C 언어용 동적 메모리 할당기를 직접 구현합니다.  
즉, `malloc`, `free`, `realloc` 루틴을 직접 설계하고 작성해야 합니다.

목표는 다음과 같습니다:

- 올바른 동작 (Correctness)  
- 효율적인 메모리 사용 (Space Utilization)  
- 빠른 처리 속도 (Throughput)

---

## 팀 구성

- 최대 2명까지 팀 구성 가능  
- 공지 및 수정 사항은 웹페이지를 통해 안내됩니다

---

## 시작하기

1. malloclab-handout.tar 압축 해제
   ```bash
   tar xvf malloclab-handout.tar
   ```
2. 수정할 파일: **mm.c**  
3. 실행용 드라이버: **mdriver.c**
   ```bash
   make
   ./mdriver -V
   ```

최종 제출 시 mm.c 파일 하나만 제출합니다.

---

## 구현해야 할 함수

```c
int mm_init(void);
void *mm_malloc(size_t size);
void mm_free(void *ptr);
void *mm_realloc(void *ptr, size_t size);
```

- **mm_init**: 힙 초기화  
- **mm_malloc**: 최소 size 바이트 블록 할당 (8바이트 정렬 보장)  
- **mm_free**: 블록 해제  
- **mm_realloc**: 블록 크기 조정  

---

## 힙 일관성 검사기

```c
int mm_check(void);
```

확인할 항목 예시:

- free 리스트에 있는 모든 블록이 실제로 free 상태인가  
- 인접 free 블록이 병합되지 않고 남아 있지 않은가  
- free 리스트의 포인터가 올바른 힙 주소를 가리키는가  
- 블록이 겹치지 않는가  

---

## 지원 루틴 (memlib.c)

- void *mem_sbrk(int incr): 힙 확장  
- void *mem_heap_lo(void): 힙 시작 주소 반환  
- void *mem_heap_hi(void): 힙 끝 주소 반환  
- size_t mem_heapsize(void): 힙 크기 반환  
- size_t mem_pagesize(void): 페이지 크기 반환  

---

## 드라이버 프로그램 (mdriver.c)

드라이버는 trace 파일에 기록된 할당/재할당/해제를 실행하며 성능과 정확성을 평가합니다.

주요 옵션:
- -t <\dir\>: trace 파일 위치 지정  
- -f <file>: 특정 trace 파일만 실행  
- -l: libc malloc과 비교 실행  
- -v: 성능 요약 출력  
- -V: 디버깅용 상세 출력  

---

## 프로그래밍 규칙

- mm.c 인터페이스 변경 금지  
- malloc, calloc, free, realloc, sbrk 등 시스템 호출 금지  
- 전역 배열/구조체/리스트 선언 불가 (정수, 포인터 등 스칼라 변수는 가능)  
- 항상 8바이트 정렬된 포인터 반환  

---

## 평가 기준

- **정확성 (20점)**: 드라이버 테스트 통과 여부  
- **성능 (35점)**  
  - 메모리 활용도 (Space Utilization)  
  - 처리량 (Throughput)  
  - 성능 지수:  
    ```
    P = wU + (1-w)min(1, T/Tlibc)
    ```
    (기본 w = 0.6, Tlibc ≈ 600Kops/s)
- **스타일 (10점)**  
  - 코드 구조, 주석, 일관성 검사기 품질  

---

## 제출

최종적으로 mm.c 파일 하나만 제출합니다.  
제출 방법은 강의 사이트 지침에 따릅니다.

---

## 힌트

- 작은 trace 파일(short1.rep, short2.rep)로 디버깅 시작  
- -v, -V 옵션 활용  
- gcc -g로 컴파일 후 gdb 디버깅  
- 교재의 암시적 free list 기반 malloc 구현 이해  
- 포인터 연산은 매크로로 캡슐화  
- 단계별 구현: malloc/free 먼저, realloc은 나중에  
- gprof 등 프로파일러 활용  
- 일찍 시작하는 것이 중요  


---

# 파일별 역할과 상호작용 

크게 나누면 메모리 관리기 구현(mm.c), 드라이버/성능 평가(mdriver.c, fsecs, fcyc, clock 등), 메모리 시뮬레이터(memlib) 로 구분됩니다

메모리 관리기 구현

- mm.c
  학생이 직접 구현하는 malloc/free/realloc 패키지

- 매크로(WSIZE, DSIZE, HDRP, FTRP, NEXT_BLKP, PREV_BLKP)로 블록의 헤더/푸터와 연결을 조작

- mm_init: 초기 힙 생성 (prologue, epilogue 블록 설정)

- mm_malloc: 요청한 크기를 ALIGN 맞추고 블록을 할당

- mm_free: 블록을 해제 후 coalesce(병합)

- mm_realloc: 새로운 블록 할당 후 기존 데이터 복사 → 기존 블록 해제

- extend_heap: 힙을 늘리고 coalesce 호출
  즉, 학생이 작성한 동적 메모리 할당기 핵심

- mm.h
  mm.c의 함수 프로토타입(mm_init, mm_malloc, mm_free, mm_realloc)과 팀 정보 구조체 team_t

메모리 시뮬레이터

- memlib.c
  실제 시스템 sbrk 대신 가상 힙 환경 제공:

- mem_sbrk: 힙 확장

- mem_heap_lo / mem_heap_hi: 힙 시작/끝 주소

- mem_heapsize: 힙 크기
  학생이 mm.c에서 사용하는 힙 관리 API

- memlib.h
  위 함수들의 선언.

드라이버 & 성능 측정

- mdriver.c

- 주 실행 파일

- trace 파일(.rep)을 읽어 mm_malloc, mm_free, mm_realloc 동작을 검증/측정

- eval_mm_valid: 올바른 동작 검사 (중복, 경계 위반 등)

- eval_mm_util: 메모리 utilization(공간 효율) 측정

- eval_mm_speed: 성능(throughput) 측정

- 결과를 종합해 점수(perf index) 출력

- config.h

- trace 파일 경로, 성능 가중치(UTIL_WEIGHT=0.6), 정답 기준(libc malloc 성능), 힙 크기 상한(20MB) 정의

- timing 방법 선택 (USE_FCYC, USE_ITIMER, USE_GETTOD)

시간/성능 측정 유틸

- 이 부분은 malloc 성능 평가용 타이머 라이브러리:

- clock.c / clock.h

- CPU cycle counter(rdtsc 등) 사용

- start_counter, get_counter로 cycle 측정

- mhz()로 CPU 주파수 추정

- start_comp_counter, get_comp_counter는 타이머 인터럽트 보정

- fcyc.c / fcyc.h

- K-best 알고리즘으로 안정적인 cycle 측정

- 여러 번 실행해서 수렴할 때까지 최소 실행시간 측정

- 옵션: cache clear, interrupt 보정, sample 개수 등

- ftimer.c / ftimer.h

- gettimeofday나 Unix interval timer 기반 시간 측정

- fcyc 못 쓰는 환경 대체

- fsecs.c / fsecs.h

- high-level wrapper

- init_fsecs()에서 타이머 초기화

- fsecs(f, argp)로 함수 실행 시간을 초 단위로 반환

- 내부적으로 fcyc/ftimer 호출

전체 흐름

- mdriver 실행
  → trace 파일 읽음 → mm.c 구현된 malloc 패키지 테스트

- memlib
  → 실제 힙 대신 가상 힙 제공

- fcyc/ftimer/fsecs/clock
  → 실행 시간, 효율성, 성능 측정

- 결과 출력
  → correctness + utilization + throughput + perf index

요약:

- 핵심 구현: mm.c (학생 과제)

- 힙 환경 제공: memlib

- 성능/정확도 검증: mdriver + trace files

- 시간 측정: clock, fcyc, fsecs, ftimer

- 환경 설정: config.h

---

# 동적 메모리 할당

명시적 할당기 - 응용이 명시적으로 할당된 블록을 반환해 줄 것을 요구
- 응용 프로그램이 명시적으로 free를 호출해야 메모리가 반환됨
- 즉, malloc으로 가져온 건 반드시 free로 돌려줘야 함
- C의 malloc/free가 전형적인 명시적 할당기

묵시적 할당기 - 할당된 블록이 더 이상 프로그램에 의해 사용되지 않고 블록을 반환하는지를 할당기가 검출할 수 있을 것을 요구(가비지 컬렉터)
- 할당기가 스스로 쓸모없는 블록(garbage)을 찾아서 회수해야 함
- 즉, 프로그래머가 free 안 해도, 할당기가 프로그램 동작을 추적해서 “더 이상 안 쓰는 메모리”를 자동으로 회수.
- Java, Python, Go 같은 언어의 **가비지 컬렉터(GC)**가 이 역할

&nbsp;

묵시적 가용 리스트 (Implicit Free List)
  특징 - 모든 블록(할당된 것 + 가용한 것)을 연속적으로 나열해서 탐색.
  각 블록에는 헤더(그리고 가끔 푸터) 가 있어서 블록의 크기와 할당 여부를 저장.
  malloc이 새 블록을 찾을 때는 힙의 처음부터 끝까지 순차적으로 돌면서 가용 블록인지 확인
  
  힙의 각 블록은 헤더(header), 페이로드(payload), 필요시 *패딩(padding)*으로 구성
  - 헤더에는 블록 전체 크기(헤더+페이로드+패딩)와 할당 여부(allocated/free)가 기록
  - 더블워드(8바이트) 정렬을 강제하면, 블록 크기는 항상 8의 배수가 되므로 블록 크기의 하위 3비트는 항상 0, 이 비트들을 “추가 정보 저장”에 활용할 수 있음 예를 들어 가장 낮은 비트 하나를 할당 여부 비트로 사용
  - 블록 크기의 상위 29비트만 저장할 필요가 있고, 나머지 3비트는 다른 정보를 인코드하기 위해 남겨둠
  - 패딩 하는 이유 - 외부 단편화 극복, 정렬 때문에

  장점 - 구현이 단순하다 블록 헤더/푸터에만 정보가 있어서 구조가 간단하다.
  단점 - 탐색 시간이 오래 걸림 → free 블록이 많아도, 할당된 블록까지 전부 훑어야 함 따라서 블록 수가 많아질수록 선형 탐색 비용 (O(n)) 발생.

&nbsp;

명시적 가용 리스트 (Explicit Free List)
  특징 - 가용 블록만 따로 연결 리스트로 관리. (할당된 블록은 리스트에 없음)
  가용 블록마다 **포인터 필드(전/후 연결)**를 추가해서 더블 링크드 리스트 형태로 유지 따라서 malloc은 이 리스트만 돌면서 가용 블록을 찾음.
  
  장점 - 탐색 범위가 훨씬 줄어듦 → 가용 블록만 관리하니까 성능 향상, 블록 삽입/삭제를 리스트 조작으로 할 수 있어 coalesce(병합)도 효율적, 다양한 변형 가능 (LIFO insert, segregated free list 등)
  단점 - 블록 내부에 **포인터 두 개(전/후)**를 저장해야 해서 추가 메모리 오버헤드 발생, 구현이 더 복잡함

  헤더 크기의 실제 값
  워드 - 4바이트


malloc 함수
- 32비트 -> 8의 배수, 64비트 -> 16의 배수
- mmap, munmap, sbrk 함수를 사용
- sbrk 함수는 커널의 brk 포인터에 incr를 더해서 힙을 늘리거나 줄인다
  - 성공하면 brk 값을 리턴하고 아니면 -1를 리턴하고 errno를 ENOMEM으로 설정
- 프로그램들은 할당된 힙 블록을 free 함수를 호출해서 반환
- 힙 블록을 free 함수를 호출해서 반환
- ptr 인자는 malloc, calloc, realloc에서 할당된 블록의 시작을 가리켜야 한다

- 처리량 극대화하기
- 메모리 이용도를 최대화하기

단편화
- 내부 단편화 - 할당된 블록이 데이터 자체보다 더 클 때 일어난다
- 외부 단편화 - 할당 요청에 만족시킬 수 있는 메모리 공간이 전체적으로 존재하지만, 처리할 수 있는 단일한 가용블록은 없는 경우

#### 구현 이슈
가용 블록 구성 - 가용 블록을 지속적으로 추적할것인가  
배치 - 가용 블록을 어떻게 선택하는가?  
분할 - 가용 블록에 배치한 후 가용 블록의 나머지 부분들로 무엇을 할 것인가?  
연결 - 반환된 블록으로 무엇을 할것인가?  

&nbsp;

![힙 블록의 포맷](/assets/images/cs/cs-app/2025-08-21-malloc-01.png)
![힙 구성하기](/assets/images/cs/cs-app/2025-08-21-malloc-02.png)

할당기의 배치 정책
- first fit, next fit, best fit
- first fit - 가용 리스트를 처음부터 검색해서 크기가 맞는 첫 번째 가용 블록을 선택
- next fit - first fit과 비슷하지만 검색을 리스트의 처음에서 시작하는 대신, 이진 검색이 종료된 지점에서 검색을 시작
- best fit - 모든 가용 블록을 검사하며 크기가 맞는 가장 작은 블록을 선택

#### 가용 블록과 free 블록 차이

둘 다 **헤더(header)**를 가진다
헤더에는 
- 블록 전체 크기
- 할당 여부 비트
- 블록 크기는 항상 8바이트 단위 정렬

할당 블록 
- 헤더의 할당 비트 = 1
- 내부 payload 영역이 사용자에게 반환
- payload 안에 사용자가 직접 저장한 데이터가 들어감
- 패딩은 정렬을 맞추기 위해 있을 수 있음
- 이 블록은 malloc에서 재사용 불가

Free 블록
- 헤더의 할당 비트 = 0
- 어떤 값이던지 무관
- 추가 메타데이터를 담는다(next/prev 포인터 저장)
- free 블록과 병합(coalescing)되어 더 큰 free 블록으로 확장

#### 오류 단편화란?
- 외부 단편화, 내부 단편화

- 묵시적 가용 리스트 - 이전 블록이 free인지 알 수 없기 때문에 푸터가 필요
- 명시적 가용 리스트 - free 블록끼리 연결 포인터(next/prev)를 유지
- 분리 가용 리스트 - 크기별로 free 블록을 여러 리스트로 관리