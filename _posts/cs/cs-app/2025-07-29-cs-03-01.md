---
layout: post
title: 컴퓨터 구조 CS:APP 3장 - 1 -
category: cs
---

#### 프로그램의 기계수준 표현

컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고,

네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속된 바이트인 **기계어 코드**(machine code)를 실행한다

GCC는 어셈블러와 링커를 호출하여 어셈블리 코드로부터 실행 가능한 기계어 코드를 생성한다

컴파일러가 어셈블리어 코드를 만들어 내는 대부분의 일을 하고 있지만,

그 코드들을 읽고 이해할 수 있는 기술은 진정한 프로그래머들에게 매우 중요한 기술이다

- 코드들을 이해하면 컴파일러의 **최적화** 성능을 알 수 있으며,

- 코드에 내재된 **비효율성**을 분석 할 수도 있다

- 프로그램의 **취약성**이 어떻게 발생하는지, 공격을 어떻게 막을 수 있을지 이해하려면

프로그램의 기계수준 표현에 대한 지식이 필요하다

C 코드로 표현된 계산에 대해서 최적화 컴파일러는 실행 순서를 조정하고

불필요한 계산을 제거하고, 느린 연산을 빠른 연산으로 교체하고

재귀적 연산들을 반복 연산으로 바꾸기도 한다

&nbsp;

#### 기계수준 코드

1. 기계 수준 프로그램의 형식과 동작은 **인스트럭션 집합구조**(ISA)에 의해 정의된다

2. 기계 수준 프로그램이 사용하는 주소는 **가상 주소**이며,

메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공 한다

&nbsp;

- **프로그램 카운터**(PC)는 실행할 다음 인스트럭션의 메모리 주소를 가리킨다

- **정수 레지스터 파일**은 64비트 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다

  레지스터는 주소나 정수 데이터를 저장할 수 있다

- **조건코드 레지스터**들은 산술 또는 논리 인스트럭션에 관한 상태 정보를 저장한다

- **벡터 레지스터**들의 집합 하나 이상의 정수나 부동소수점 값들을 각각 저장할 수 있다

기계어 코드는 메모리를 단순히 바이트 주소지정이 가능한 큰 배열로 본다

&nbsp;

프로그램 메모리는 프로그램의 실행 기계어 코드, 운영체제를 위한 일부 정보,

프로시저 호출과 리턴을 관리하는 런타임 스택, 사용자의 의해 할당된(malloc) 메모리 블록들을 포함하고 있다

**운영체제**는 이 가상 주소공간을 관리해서 가상주소를 실제 프로세서 메모리 상의 물리적 주소 값으로 번역

&nbsp;

![목적코드와 어셈블리어](/assets/images/cs/cs-app/cs-app-03-01-01.png)

왼쪽은 어셈블리 인스트럭션에 대응되는 목적코드이다

중요한 교훈은 실제 실행된 프로그램은 인스트럭션을 인코딩한 바이트라는 점이다