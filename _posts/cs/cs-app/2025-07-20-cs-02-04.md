---
layout: post
title: 컴퓨터 구조 CS:APP 2장 - 4 -
category: cs
---

# Index
- [스트링의 표시](#스트링의-표시)
- [코드의 표현](#코드의-표현)
- [부울 Boolean 대수](#부울-boolean-대수)
- [C에서의 비트수준 연산](#c에서의-비트수준-연산)
- [C에서의 논리 연산](#c에서의-논리-연산)
- [C에서의 쉬프트 연산](#c에서의-쉬프트-연산)

#### 스트링의 표시

C에서 스트링은 **널**(값 0을 갖는) 문자로 종료하는 문자열로 인코딩된다

**ASCII**를 문자코드로 사용하는 모든 컴퓨터에서 바이트 순서나 워드 크기와 무관하게 똑같이 얻을 수 있다

> **텍스트** 데이터는 이진 데이터보다 플랫폼 독립적이다

&nbsp;

#### 코드의 표현

```c
int sum(int x, int y) {
  return x + y;
}  
```

![기계어코드](/assets/images/cs/cs-app/cs-app-02-04-01.png)

인스트럭션들의 인코딩이 모두 **다르다**는 것을 알 수 있음

이진 코드는 컴퓨터와 운영체제들의 여러 가지 조합들 간에 **호환성**을 갖는 경우가 드물다

컴퓨터는 디버깅 시 도움을 주기 위해 관리하는 일부의 보조용 표를 제외하고는  

본래의 소스 프로그램에 대한 정보를 전혀 가지고 있지 않다

&nbsp;

#### 부울 Boolean 대수

1850년경 George Boole(1815 ~ 1864)의 연구결과로 **부울 대수**(Boolean algebra)가 있다

Boole은 이진수 값 1과 0을 논리값 TRUE와 FALSE로 인코딩하면 논리 추론의 기본 원리들을

구현할 수 있는 대수학을 수식화할 수 있다는 점을 발견하였다

&nbsp;

~P는 P가 참이 아니라면 참이 되고, 그 반대도 마찬가지다

P가 참이고 Q가 참일 때, P & Q도 참이고 P \| Q도 참이다

(XOR) exclusive or은 P 혹은 Q가 둘 중에 참이 있으면서, 양쪽 모두가 참이 아닌 경우만 참이다

![부울 대수 연산](/assets/images/cs/cs-app/cs-app-02-04-02.png)

비트 **벡터 마스크**(mask)라는 것을 설정해서 특정 시그널을 선택적으로 활성화 또는 비활성화 할 수 있다

&nbsp;

#### C에서의 비트수준 연산

![char 데이터 타입 수식 계산](/assets/images/cs/cs-app/cs-app-02-04-03.png)

예제에서 보는 것처럼 비트수준 수식의 효과를 알 수 있는 가장 좋은 방법은  

16진수 인자들을 이진수로 표시 확장해서 이진수에서 연산을 실행하고 다시 16진수로 변환하는 것이다

비트수준 연산은 **마스크 연산**을 구현할 때 사용한다

비트수준 연산 **x&0xFF**는 다른 바이트는 0으로 하고, x의 가장 덜 중요한 바이트만으로 구성된 값을 나타냄  

&nbsp;

- & 연산

  0x89ABCDEF  
  0x000000FF  
  ------------  
  0x000000EF   

&nbsp;

#### C에서의 논리 연산

**논리 연산**은 0이 아닌 인자들을 **참**으로 취급하고 0은 **거짓**으로 처리한다

논리 연산자와 비트 연산자의 중요한 **차이**는 수식의 결과가 첫 번째 인자를 계산해서 결정될 수 있으면

두번째 인자는 **계산**하지 않는다는 것이다 

예를 들면 a가 0일때, a && 5/a는 0으로 나누기(division by zero) 오류를 절대 발생시키지 않으며

식 p && *p++은 널 포인터의 역참조를 절대 발생시키지 않는다

&nbsp;

#### C에서의 쉬프트 연산

C는 비트 패턴을 좌우로 이동시키는 **쉬프트** 연산 집합을 제공한다

x << k는 x는 좌측으로 k비트 이동하고, 중요한 좌측의 k비트가 밀려서   

삭제되며 우측에는 k개의 0으로 채워진다 

C 언어에서는 우측 쉬프트 연산 x >> k가 있다 

- 논리 우측 쉬프트 : 좌측 끝에 k개의 0들로 채워서 만든다

- 산술 우측 쉬프트 : 좌측 끝에 가장 중요한 비트를 k개 반복해서 채워서 만든다

![char 데이터 타입 수식 계산](/assets/images/cs/cs-app/cs-app-02-04-04.png)  

&nbsp;

C 표준은 어떤 타입의 우측 쉬프트가 사용되어야 하는지 명확히 **정의**하고 있지 않음

많은 컴파일러들은 **부호형 데이터**에 대해서 **산술 우측 쉬프트**를 사용하고 있으며,

**비부호형 데이터**에 대해서는 우측 쉬프트는 **논리 쉬프트**여야 한다

부호형(signed) - 산술 우측 쉬프트 (**부호 비트**로 채움)

비부호형(unsigned) - 논리 우측 쉬프트 (**0**으로 채움)


<p style="display: flex; justify-content: space-between;">
<a href="cs-02-03.html">이전</a>
<a href="cs-02-05.html">다음</a>
</p>